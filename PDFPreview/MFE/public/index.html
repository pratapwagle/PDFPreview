<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Preview App</title>
    <!-- PDF.js for advanced PDF rendering support -->
    <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
    <script>
        // Configure PDF.js when it loads
        if (window.pdfjsLib) {
            window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js';
        }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .controls {
            padding: 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .input-group {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .file-input {
            flex: 1;
            min-width: 300px;
            padding: 15px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .file-input:focus {
            outline: none;
            border-color: #4facfe;
            box-shadow: 0 0 0 3px rgba(79, 172, 254, 0.1);
        }

        .preview-btn {
            padding: 15px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 150px;
        }

        .select-btn {
            padding: 15px 20px;
            background: linear-gradient(135deg, #56ab2f 0%, #a8e6cf 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            min-width: 130px;
        }

        .preview-btn:hover, .select-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .select-btn:hover {
            box-shadow: 0 10px 20px rgba(86, 171, 47, 0.3);
        }

        .preview-btn:active {
            transform: translateY(0);
        }

        .preview-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
            display: none;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.loading {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .pdf-container {
            padding: 20px;
            min-height: 400px;
            background: #f8f9fa;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .pdf-container #pdfPages {
            width: 100%;
            max-width: 100%;
        }

        .pdf-container #pdfPages canvas {
            max-width: 100%;
            height: auto;
        }

        .pdf-frame {
            width: 100%;
            height: 70vh;
            border: none;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            background: white;
        }

        .placeholder {
            text-align: center;
            color: #6c757d;
            font-size: 1.2em;
        }

        .placeholder-icon {
            font-size: 4em;
            margin-bottom: 20px;
            opacity: 0.3;
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4facfe;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 2s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .example-paths {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }

        .example-paths h3 {
            color: #495057;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .example-paths ul {
            list-style: none;
            padding: 0;
        }

        .example-paths li {
            padding: 8px 12px;
            background: #f8f9fa;
            margin: 5px 0;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #495057;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .example-paths li:hover {
            background: #e9ecef;
        }

        /* Timing Display Styles */
        .timing-section {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin: 20px;
            border: 1px solid #e9ecef;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .timing-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            font-size: 1.1em;
            font-weight: 600;
            color: #495057;
        }

        .timing-icon {
            margin-right: 8px;
            font-size: 1.2em;
        }

        .timing-display {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .timing-item {
            flex: 1;
            min-width: 200px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
            border-left: 4px solid #007acc;
        }

        .timing-item.loading {
            border-left-color: #007bff;
            background: #e7f3ff;
        }

        .timing-item.success {
            border-left-color: #28a745;
            background: #e8f5e8;
        }

        .timing-item.error {
            border-left-color: #dc3545;
            background: #ffeaea;
        }

        .timing-label {
            font-size: 0.9em;
            color: #6c757d;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .timing-value {
            font-size: 1.4em;
            font-weight: 600;
            color: #495057;
        }

        .timing-details {
            font-size: 0.8em;
            color: #6c757d;
            margin-top: 5px;
        }

        @media (max-width: 768px) {
            .input-group {
                flex-direction: column;
            }
            
            .file-input {
                min-width: auto;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .controls {
                padding: 20px;
            }
        }

        /* UWP-specific styles */
        .uwp-mode .header {
            background: linear-gradient(135deg, #0078d4 0%, #005a9e 100%);
        }

        .uwp-mode .header p {
            font-size: 1em;
        }

        .uwp-mode .preview-btn {
            background: linear-gradient(135deg, #0078d4 0%, #005a9e 100%);
        }

        .uwp-mode .preview-btn:hover {
            box-shadow: 0 10px 20px rgba(0, 120, 212, 0.3);
        }

        .uwp-mode .file-input:disabled,
        .uwp-mode .file-input[readonly] {
            background-color: #f3f2f1;
            color: #605e5c;
            border-color: #c8c6c4;
            cursor: not-allowed;
        }

        /* Loading spinner for UWP operations */
        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #4facfe;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 2s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>📄 PDF Preview</h1>
            <p>Upload and preview PDF files instantly in your browser</p>
        </div>
        
        <div class="controls">
            <div class="input-group">
                <input 
                    type="text" 
                    id="filePath" 
                    class="file-input" 
                    placeholder="Enter the full path to your PDF file (e.g., C:\Documents\sample.pdf)"
                >
                <input 
                    type="file" 
                    id="fileSelector" 
                    accept=".pdf"
                    style="display: none;"
                >
                <button id="selectFileBtn" class="select-btn">📁 Select File</button>
                <button id="previewBtn" class="preview-btn">Preview PDF</button>
            </div>
            
            <div id="status" class="status"></div>
        </div>

        <!-- Timing Display Section -->
        <div class="timing-section" id="timingSection" style="display: none;">
            <div class="timing-header">
                <span class="timing-icon">⏱️</span>
                PDF Loading Performance
            </div>
            <div class="timing-display">
                <div class="timing-item" id="currentOperation">
                    <div class="timing-label">Current Operation</div>
                    <div class="timing-value" id="operationStatus">Ready</div>
                    <div class="timing-details" id="operationDetails">Waiting for PDF load request</div>
                </div>
                <div class="timing-item" id="lastTiming">
                    <div class="timing-label">Last Load Time</div>
                    <div class="timing-value" id="lastDuration">--</div>
                    <div class="timing-details" id="lastMethod">No previous loads</div>
                </div>
                <div class="timing-item" id="averageTiming">
                    <div class="timing-label">Average Time</div>
                    <div class="timing-value" id="avgDuration">--</div>
                    <div class="timing-details" id="totalLoads">0 loads completed</div>
                </div>
            </div>
        </div>
        
        <div class="pdf-container" id="pdfContainer">
            <div class="placeholder">
                <div class="placeholder-icon">📄</div>
                <p>Enter a PDF file path above or click "Select File" to choose a PDF document</p>
            </div>
        </div>
    </div>

    <script>
        const filePathInput = document.getElementById('filePath');
        const fileSelector = document.getElementById('fileSelector');
        const selectFileBtn = document.getElementById('selectFileBtn');
        const previewBtn = document.getElementById('previewBtn');
        const statusDiv = document.getElementById('status');
        const pdfContainer = document.getElementById('pdfContainer');

        let currentFile = null;
        let isInUWP = false;

        // UWP PDF Integration Class - matches sample-mfe-integration.js
        class UWPPDFIntegration {
            constructor() {
                this.isInUWP = this.checkUWPEnvironment();
                this.initializeMessageHandler();
                this.notifyReady();
                
                // Chunked streaming state
                this.chunkingState = {
                    isReceiving: false,
                    chunks: [],
                    expectedChunks: 0,
                    fileName: '',
                    totalSize: 0,
                    receivedChunks: 0,
                    transferMethod: 'Unknown'
                };

                // Timing tracking state
                this.timingState = {
                    startTime: null,
                    endTime: null,
                    currentOperation: 'Ready',
                    operationDetails: 'Waiting for PDF load request',
                    loadTimes: [],
                    currentMethod: 'Unknown'
                };

                this.initializeTimingDisplay();
            }

            checkUWPEnvironment() {
                return !!(window.chrome && window.chrome.webview);
            }

            initializeMessageHandler() {
                // Listen for messages from UWP WebView2
                if (this.isInUWP) {
                    console.log('Initializing UWP message handler');
                    window.chrome.webview.addEventListener('message', (event) => {
                        this.handleUWPMessage(event.data);
                    });
                }
            }

            handleUWPMessage(data) {
                try {
                    console.log('Received UWP message:', data);
                    const message = typeof data === 'string' ? JSON.parse(data) : data;
                    
                    switch (message.type) {
                        case 'LOAD_PDF':
                            const transferMethod = message.transferMethod || 'Unknown';
                            console.log(`Loading PDF: ${message.fileName || 'Unknown'} (${message.urlType || 'unknown'} URL, Method: ${transferMethod})`);
                            
                            // Log additional details for virtual host URLs
                            if (message.pdfUrl && message.pdfUrl.startsWith('https://localassets.web/')) {
                                console.log('🌐 Virtual Host URL detected - using secure local file mapping');
                                console.log(`Virtual URL: ${message.pdfUrl}`);
                            }
                            
                            this.loadPDF(message.pdfUrl, message.urlType, message.fileName, message.fileSize, transferMethod);
                            break;
                        case 'LOAD_PDF_CHUNKED_START':
                            const chunkTransferMethod = message.transferMethod || 'ChunkedStream';
                            console.log(`Starting chunked PDF load: ${message.fileName || 'Unknown'} (Method: ${chunkTransferMethod})`);
                            this.startChunkedPDFLoad(message);
                            break;
                        case 'LOAD_PDF_CHUNK':
                            this.receiveChunk(message);
                            break;
                        case 'LOAD_PDF_CHUNKED_ERROR':
                            console.error('Chunked loading error:', message.error);
                            this.resetChunkingState();
                            this.sendMessageToUWP({
                                type: 'PDF_ERROR',
                                error: `Chunked loading failed: ${message.error}`,
                                transferMethod: message.transferMethod || 'ChunkedStream'
                            });
                            break;
                        case 'loadPDF':  // Backward compatibility
                            this.loadPDF(message.filePath, 'unknown', 'Unknown', 0, 'Legacy');
                            break;
                        case 'CLEAR_PDF':
                            this.clearPDF();
                            break;
                        case 'clearPreview':  // Backward compatibility
                            this.clearPDF();
                            break;
                        default:
                            console.log('Unknown message type from UWP:', message.type);
                            this.sendMessageToUWP({
                                type: 'MESSAGE_ERROR',
                                error: `Unknown message type: ${message.type}`,
                                receivedMessage: message
                            });
                    }
                } catch (error) {
                    console.error('Error handling UWP message:', error);
                    this.sendMessageToUWP({
                        type: 'PDF_ERROR',
                        error: error.message
                    });
                }
            }

            async loadPDF(pdfUrl, urlType = 'unknown', fileName = '', fileSize = 0, transferMethod = 'Unknown') {
                try {
                    console.log(`Loading PDF from UWP: ${pdfUrl} (Type: ${urlType}, Method: ${transferMethod})`);
                    
                    // Start timing for this operation
                    this.startTiming('Loading PDF', transferMethod, `Loading ${fileName || 'PDF'} using ${transferMethod}`);
                    
                    if (!pdfUrl) {
                        throw new Error('No PDF URL provided');
                    }

                    // Update UI to show loading
                    this.showLoadingState();
                    filePathInput.value = fileName ? `Loading ${fileName} from UWP...` : "Loading from UWP secure storage...";
                    
                    // Handle different URL types for cloud MFE compatibility
                    if (pdfUrl.startsWith('uwp-pdf://')) {
                        // Custom stream handler - optimal performance
                        await this.loadStreamPDF(pdfUrl, urlType, fileName, fileSize, transferMethod);
                    } else if (pdfUrl.startsWith('file:///')) {
                        // File URLs - works with cloud-hosted MFE (primary method)
                        await this.loadFileSystemPDF(pdfUrl, transferMethod);
                    } else if (pdfUrl.startsWith('https://localassets.web/')) {
                        // Virtual host mapping - modern secure approach
                        await this.loadVirtualHostPDF(pdfUrl, transferMethod);
                    } else if (pdfUrl.startsWith('https://pdf-assets.uwp/')) {
                        // Legacy virtual host mapping (backward compatibility)
                        await this.loadVirtualHostPDF(pdfUrl, transferMethod);
                    } else if (pdfUrl.startsWith('ms-appdata:///')) {
                        // Legacy ms-appdata URLs (backward compatibility)
                        await this.loadVirtualHostPDF(pdfUrl, transferMethod);
                    } else if (pdfUrl.startsWith('data:application/pdf')) {
                        // Base64 data URL (alternative approach)
                        await this.loadDataUrlPDF(pdfUrl, transferMethod);
                    } else {
                        throw new Error('Unsupported PDF URL format: ' + pdfUrl);
                    }
                    
                    // Note: Timing is ended by individual loading methods when PDF is actually loaded
                    
                } catch (error) {
                    console.error('Error loading PDF:', error);
                    
                    // End timing on error
                    this.endTiming(false, `Failed to load PDF: ${error.message}`);
                    
                    this.sendMessageToUWP({
                        type: 'PDF_ERROR',
                        error: error.message,
                        urlType: urlType,
                        transferMethod: transferMethod
                    });
                    showStatus(`Error loading PDF: ${error.message}`, 'error');
                }
            }

            async loadStreamPDF(streamUrl, urlType, fileName = '', fileSize = 0, transferMethod = 'CustomStream') {
                console.log(`Loading PDF from custom stream: ${streamUrl} (${fileName}, ${fileSize} bytes, Method: ${transferMethod})`);
                
                // Notify UWP that we're starting to load via custom stream
                this.sendMessageToUWP({
                    type: 'PDF_LOADING',
                    message: `Starting to load PDF from custom stream: ${fileName}`,
                    url: streamUrl,
                    method: 'custom-stream',
                    fileSize: fileSize,
                    transferMethod: transferMethod
                });
                
                // Method 1: Direct iframe (recommended for custom streams)
                if (this.useIframeMethod()) {
                    this.loadPDFInIframe(streamUrl, transferMethod);
                    this.sendMessageToUWP({
                        type: 'PDF_LOADED',
                        message: `PDF loaded via custom stream in iframe successfully: ${fileName}`,
                        method: 'iframe',
                        urlType: urlType,
                        fileName: fileName,
                        fileSize: fileSize,
                        transferMethod: transferMethod
                    });
                    return;
                }
                
                // Method 2: PDF.js with fetch (also works with custom streams)
                if (window.pdfjsLib) {
                    try {
                        console.log('Attempting to load custom stream with PDF.js...');
                        
                        const response = await fetch(streamUrl);
                        if (!response.ok) {
                            throw new Error(`Stream fetch error! status: ${response.status}`);
                        }
                        
                        const arrayBuffer = await response.arrayBuffer();
                        const loadingTask = window.pdfjsLib.getDocument(new Uint8Array(arrayBuffer));
                        const pdf = await loadingTask.promise;
                        
                        console.log('PDF loaded via custom stream with PDF.js');
                        await this.renderPDF(pdf);
                        // Add a small delay to account for browser's final paint operations
                        setTimeout(() => {
                            this.onPDFLoaded('pdfjs', transferMethod);
                        }, 100);
                        return;
                    } catch (pdfError) {
                        console.warn('PDF.js custom stream loading failed:', pdfError);
                        // Fallback to iframe
                        this.loadPDFInIframe(streamUrl, transferMethod);
                        return;
                    }
                }
                
                // Final fallback: Direct iframe
                this.loadPDFInIframe(streamUrl, transferMethod);
            }

            async loadFileSystemPDF(fileUrl, transferMethod = 'FileURL') {
                console.log(`Loading PDF from file system: ${fileUrl} (Method: ${transferMethod})`);
                
                // Notify UWP that we're starting to load
                this.sendMessageToUWP({
                    type: 'PDF_LOADING',
                    message: 'Starting to load PDF from file system',
                    url: fileUrl,
                    method: 'file-system',
                    transferMethod: transferMethod
                });
                
                // Check if this is a WebView2 environment
                const isWebView2 = !!(window.chrome && window.chrome.webview);
                console.log('Running in WebView2:', isWebView2);
                
                if (!isWebView2) {
                    // In regular browsers, file:// URLs typically don't work due to security restrictions
                    // Try to convert to data URL or suggest alternative
                    const errorMsg = 'File URLs are not supported in regular browsers due to security restrictions. This feature requires UWP WebView2 environment with proper file access configuration.';
                    console.warn(errorMsg);
                    
                    // Show a more helpful error message
                    const container = document.getElementById('pdfContainer');
                    if (container) {
                        container.innerHTML = `
                            <div class="placeholder">
                                <div class="placeholder-icon">⚠️</div>
                                <h3>File URL Not Supported</h3>
                                <p>File URLs (${fileUrl}) are not supported in regular browsers due to security restrictions.</p>
                                <p><strong>Solutions:</strong></p>
                                <ul style="text-align: left; max-width: 500px; margin: 0 auto;">
                                    <li>Run this in UWP WebView2 with proper file access configuration</li>
                                    <li>Use the UWP app to copy files to accessible locations</li>
                                    <li>Convert to data URLs or use server-based file access</li>
                                </ul>
                            </div>
                        `;
                    }
                    
                    this.sendMessageToUWP({
                        type: 'PDF_ERROR',
                        error: errorMsg,
                        method: 'file-system-security-restriction',
                        suggestion: 'Use UWP WebView2 environment or data URLs',
                        transferMethod: transferMethod
                    });
                    showStatus(errorMsg, 'error');
                    return;
                }
                
                // Method 1: Direct iframe (most reliable for file URLs in WebView2)
                if (this.useIframeMethod()) {
                    this.loadPDFInIframe(fileUrl, transferMethod);
                    return;
                }
                
                // Method 2: PDF.js with fetch (may require additional permissions)
                if (window.pdfjsLib) {
                    try {
                        console.log('Attempting to load with PDF.js...');
                        
                        // Fetch the file content
                        const response = await fetch(fileUrl);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const arrayBuffer = await response.arrayBuffer();
                        const loadingTask = window.pdfjsLib.getDocument(new Uint8Array(arrayBuffer));
                        const pdf = await loadingTask.promise;
                        
                        await this.renderPDF(pdf);
                        
                        // Add a small delay to account for browser's final paint operations
                        setTimeout(() => {
                            this.onPDFLoaded('pdfjs', transferMethod);
                        }, 100);
                        
                    } catch (fetchError) {
                        console.warn('PDF.js fetch failed, falling back to iframe:', fetchError);
                        this.loadPDFInIframe(fileUrl, transferMethod);
                    }
                } else {
                    // Fallback to iframe if PDF.js not available
                    this.loadPDFInIframe(fileUrl, transferMethod);
                }
            }

            async loadVirtualHostPDF(virtualUrl, transferMethod = 'VirtualHost') {
                console.log(`Loading PDF from virtual host: ${virtualUrl} (Method: ${transferMethod})`);
                
                         
                // Check if this is lazy loading or normal loading based on transfer method
                const isLazyLoading = transferMethod.includes('Lazy') || transferMethod.includes('lazy');
                
                // Notify UWP that we're starting to load from virtual host
                this.sendMessageToUWP({
                    type: 'PDF_LOADING',
                    message: `Loading PDF from virtual host mapping${isLazyLoading ? ' with lazy loading' : ''}`,
                    url: virtualUrl,
                    method: isLazyLoading ? 'virtual-host-lazy' : 'virtual-host',
                    transferMethod: transferMethod
                });
                
                // Start timing for virtual host loading
                this.startTiming('Loading PDF (VirtualHost)', transferMethod, `Loading PDF${isLazyLoading ? ' with lazy loading' : ''} from ${virtualUrl}`);
                
                // Choose loading method based on transferMethod
                if (isLazyLoading) {
                    // Use lazy loading with PDF.js for better performance
                    if (window.pdfjsLib) {
                        try {
                            console.log('🚀 Using PDF.js with lazy loading for virtual host URL');
                            await this.loadLazyVirtualHostPDF(virtualUrl, transferMethod);
                            return;
                        } catch (error) {
                            console.warn('PDF.js lazy loading failed:', error);
                            console.log('Falling back to iframe method...');
                        }
                    }
                } else {
                    // Use normal loading (complete PDF at once)
                    if (window.pdfjsLib) {
                        try {
                            console.log('📄 Using PDF.js with normal loading for virtual host URL');
                            await this.loadNormalVirtualHostPDF(virtualUrl, transferMethod);
                            return;
                        } catch (error) {
                            console.warn('PDF.js normal loading failed:', error);
                            console.log('Falling back to iframe method...');
                        }
                    }
                }
                
                // Fallback: Direct iframe (for when PDF.js fails or isn't available)
                console.log('Loading virtual host PDF in iframe...');
                this.loadPDFInIframe(virtualUrl, transferMethod);
            }

            async loadNormalVirtualHostPDF(virtualUrl, transferMethod) {
                try {
                    console.log('📄 Loading complete PDF with PDF.js (normal mode)');
                    
                    // Show loading UI
                    this.showLoadingState();
                    
                    // Load complete PDF at once
                    const response = await fetch(virtualUrl);
                    if (!response.ok) {
                        throw new Error(`Virtual host fetch error! status: ${response.status}`);
                    }
                    
                    const arrayBuffer = await response.arrayBuffer();
                    const loadingTask = window.pdfjsLib.getDocument(new Uint8Array(arrayBuffer));
                    const pdf = await loadingTask.promise;
                    
                    console.log(`✅ PDF loaded completely: ${pdf.numPages} pages`);
                    this.endTiming(true, `PDF loaded completely (${pdf.numPages} pages)`);
                    
                    // Render all pages at once
                    await this.renderPDF(pdf);
                    
                    // Add a small delay to account for browser's final paint operations
                    setTimeout(() => {
                        this.onPDFLoaded('pdfjs-normal', transferMethod);
                    }, 100);
                    
                } catch (error) {
                    console.error('Failed to load PDF in normal mode:', error);
                    throw error; // Re-throw to trigger fallback
                }
            }

            async loadLazyVirtualHostPDF(virtualUrl, transferMethod) {
                try {
                    // Show immediate loading UI
                    this.showLazyLoadingUI(virtualUrl, transferMethod);
                    
                    // Configure PDF.js for lazy loading with range requests
                    const loadingTask = window.pdfjsLib.getDocument({
                        url: virtualUrl,
                        // Enable range requests for lazy loading
                        rangeChunkSize: 65536, // 64KB chunks for smooth loading
                        disableAutoFetch: true, // Don't fetch all pages at once
                        disableStream: false,   // Allow streaming
                        disableRange: false     // Enable HTTP range requests
                    });
                    
                    // Wait for PDF structure to load (just header and page index)
                    const pdf = await loadingTask.promise;
                    
                    console.log(`✅ PDF structure loaded: ${pdf.numPages} pages available for lazy loading`);
                    this.endTiming(true, `PDF structure loaded (${pdf.numPages} pages)`);
                    
                    // Set up lazy loading viewer with page-by-page rendering
                    this.setupLazyLoadPDFViewer(pdf, virtualUrl, transferMethod);
                    
                } catch (error) {
                    console.error('Failed to load PDF structure for lazy loading:', error);
                    throw error; // Re-throw to trigger fallback
                }
            }

            showLazyLoadingUI(virtualUrl, transferMethod) {
                const container = document.getElementById('pdfContainer');
                if (container) {
                    container.style.cssText = `
                        padding: 0;
                        background: #525659;
                        display: flex;
                        flex-direction: column;
                        width: 100%;
                        min-height: 70vh;
                    `;
                    
                    container.innerHTML = `
                        <div style="
                            background: #333;
                            color: white;
                            padding: 15px;
                            text-align: center;
                            border-bottom: 2px solid #555;
                        ">
                            <div class="loading-spinner" style="margin: 0 auto 10px auto;"></div>
                            <h3 style="margin: 0 0 10px 0;">🔄 Loading PDF Structure...</h3>
                            <p style="margin: 0; opacity: 0.8;">Preparing lazy loading viewer...</p>
                        </div>
                        <div style="
                            flex: 1;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            color: white;
                            opacity: 0.6;
                        ">
                            <div style="text-align: center;">
                                <div style="font-size: 4em; margin-bottom: 20px;">📄</div>
                                <p>Initializing Virtual Host Lazy Loading...</p>
                                <p style="font-size: 0.9em; margin-top: 10px;">First page will load immediately</p>
                            </div>
                        </div>
                    `;
                }
                showStatus('Loading PDF structure for lazy viewing...', 'loading');
            }

            setupLazyLoadPDFViewer(pdf, virtualUrl, transferMethod) {
                const container = document.getElementById('pdfContainer');
                let currentPageNum = 1;
                const totalPages = pdf.numPages;
                let pageCache = new Map(); // Cache rendered pages
                
                // Start timing for first page render
                this.startTiming('Rendering First Page', transferMethod, 'Loading page 1 for immediate preview');

                container.style.cssText = `padding: 0; background: #525659; width: 100%; min-height: 70vh;`;
                container.innerHTML = `
                    <div style="display: flex; flex-direction: column; height: 100vh; width: 100%;">
                        <!-- Navigation Controls -->
                        <div id="pdf-lazy-controls" style="
                            padding: 10px 15px;
                            background: linear-gradient(135deg, #2c3e50, #34495e);
                            color: white;
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
                            border-bottom: 1px solid #555;
                        ">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <button id="prev-page" style="
                                    background: #3498db;
                                    color: white;
                                    border: none;
                                    padding: 8px 12px;
                                    border-radius: 4px;
                                    cursor: pointer;
                                    font-size: 14px;
                                ">◄ Prev</button>
                                <span style="
                                    display: flex;
                                    align-items: center;
                                    gap: 5px;
                                    font-weight: 500;
                                ">
                                    Page 
                                    <input type="number" id="page-num" value="1" min="1" max="${totalPages}" style="
                                        width: 60px;
                                        text-align: center;
                                        padding: 4px;
                                        border: 1px solid #555;
                                        border-radius: 3px;
                                        background: #2c3e50;
                                        color: white;
                                    "> 
                                    of ${totalPages}
                                </span>
                                <button id="next-page" style="
                                    background: #3498db;
                                    color: white;
                                    border: none;
                                    padding: 8px 12px;
                                    border-radius: 4px;
                                    cursor: pointer;
                                    font-size: 14px;
                                ">Next ►</button>
                            </div>
                            
                            <div style="display: flex; align-items: center; gap: 15px;">
                                <div id="loading-indicator" style="
                                    display: none;
                                    color: #f39c12;
                                    font-size: 14px;
                                ">
                                    🔄 Loading page...
                                </div>
                                <div style="font-size: 14px; opacity: 0.8;">
                                    Virtual Host Lazy Loading
                                </div>
                            </div>
                        </div>

                        <!-- PDF Render Area -->
                        <div id="pdf-lazy-render" style="
                            flex: 1;
                            padding: 20px;
                            overflow: auto;
                            text-align: center;
                            background: #525659;
                        ">
                            <div id="page-container" style="
                                display: inline-block;
                                background: white;
                                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
                                border-radius: 8px;
                                padding: 10px;
                                margin: 0 auto;
                            ">
                                <canvas id="pdf-canvas" style="
                                    display: block;
                                    max-width: 100%;
                                    height: auto;
                                "></canvas>
                            </div>
                            
                            <div id="page-info" style="
                                margin-top: 15px;
                                color: white;
                                font-size: 14px;
                                opacity: 0.7;
                            ">
                                Lazy loading enabled - pages load on demand
                            </div>
                        </div>
                    </div>
                `;

                const pageNumInput = document.getElementById('page-num');
                const prevBtn = document.getElementById('prev-page');
                const nextBtn = document.getElementById('next-page');
                const canvas = document.getElementById('pdf-canvas');
                const context = canvas.getContext('2d');
                const loadingIndicator = document.getElementById('loading-indicator');
                const pageInfo = document.getElementById('page-info');

                const showLoading = (show) => {
                    loadingIndicator.style.display = show ? 'block' : 'none';
                };

                const renderPage = async (num, showTiming = true) => {
                    try {
                        if (showTiming) {
                            this.startTiming(`Loading Page ${num}`, transferMethod, `Lazy loading page ${num} of ${totalPages}`);
                        }
                        
                        showLoading(true);
                        pageInfo.textContent = `Loading page ${num}...`;
                        
                        // Check cache first
                        if (pageCache.has(num)) {
                            console.log(`📋 Using cached page ${num}`);
                            const cachedImageData = pageCache.get(num);
                            canvas.width = cachedImageData.width;
                            canvas.height = cachedImageData.height;
                            context.putImageData(cachedImageData.imageData, 0, 0);
                            
                            showLoading(false);
                            pageInfo.textContent = `Page ${num} (cached)`;
                            
                            if (showTiming) {
                                this.endTiming(true, `Page ${num} loaded from cache`);
                            }
                            return;
                        }
                        
                        // Fetch page on demand (this triggers HTTP range request)
                        console.log(`🔄 Fetching page ${num} on demand...`);
                        const page = await pdf.getPage(num);
                        
                        // Calculate optimal scale for container
                        const container = document.getElementById('pdf-lazy-render');
                        const maxWidth = container.clientWidth - 60; // Account for padding
                        const viewport = page.getViewport({ scale: 1.0 });
                        const scale = Math.min(maxWidth / viewport.width, 2.5, window.devicePixelRatio || 1);
                        const scaledViewport = page.getViewport({ scale: scale });
                        
                        // Set canvas dimensions
                        canvas.height = scaledViewport.height;
                        canvas.width = scaledViewport.width;
                        
                        // Render the page
                        await page.render({ canvasContext: context, viewport: scaledViewport }).promise;
                        
                        // Cache the rendered page
                        const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
                        pageCache.set(num, {
                            imageData: imageData,
                            width: canvas.width,
                            height: canvas.height
                        });
                        
                        console.log(`✅ Page ${num} rendered and cached`);
                        
                        showLoading(false);
                        pageInfo.textContent = `Page ${num} of ${totalPages} (loaded via range request)`;
                        
                        // Update controls
                        pageNumInput.value = num;
                        prevBtn.disabled = num <= 1;
                        nextBtn.disabled = num >= totalPages;
                        
                        if (showTiming) {
                            this.endTiming(true, `Page ${num} loaded and rendered`);
                        }
                        
                        // Notify UWP of successful page load
                        this.sendMessageToUWP({
                            type: 'PDF_PAGE_LOADED',
                            message: `Page ${num} loaded via lazy loading`,
                            page: num,
                            totalPages: totalPages,
                            method: 'virtual-host-lazy',
                            transferMethod: transferMethod
                        });
                        
                    } catch (error) {
                        console.error(`❌ Error rendering page ${num}:`, error);
                        showLoading(false);
                        pageInfo.textContent = `Error loading page ${num}: ${error.message}`;
                        
                        if (showTiming) {
                            this.endTiming(false, `Failed to load page ${num}: ${error.message}`);
                        }
                    }
                };

                // Navigation event handlers
                prevBtn.onclick = () => { 
                    if (currentPageNum > 1) {
                        currentPageNum--;
                        renderPage(currentPageNum);
                    }
                };
                
                nextBtn.onclick = () => { 
                    if (currentPageNum < totalPages) {
                        currentPageNum++;
                        renderPage(currentPageNum);
                    }
                };
                
                pageNumInput.onchange = () => {
                    const newPage = parseInt(pageNumInput.value);
                    if (newPage > 0 && newPage <= totalPages && newPage !== currentPageNum) {
                        currentPageNum = newPage;
                        renderPage(currentPageNum);
                    }
                };

                // Keyboard navigation
                document.addEventListener('keydown', (e) => {
                    if (e.target.tagName.toLowerCase() === 'input') return; // Don't interfere with input fields
                    
                    if (e.key === 'ArrowLeft' && currentPageNum > 1) {
                        currentPageNum--;
                        renderPage(currentPageNum);
                        e.preventDefault();
                    } else if (e.key === 'ArrowRight' && currentPageNum < totalPages) {
                        currentPageNum++;
                        renderPage(currentPageNum);
                        e.preventDefault();
                    }
                });

                // Load the first page immediately
                renderPage(currentPageNum);
                
                // Notify successful lazy loading setup
                setTimeout(() => {
                    this.onPDFLoaded('lazy-virtual-host', transferMethod);
                    showStatus(`PDF ready for lazy loading (${totalPages} pages)`, 'success');
                }, 100);
            }

            async loadDataUrlPDF(dataUrl, transferMethod = 'DataURL') {
                // Support for Base64 data URLs
                console.log(`Loading PDF from data URL... (Method: ${transferMethod})`);
                console.log(`Data URL length: ${dataUrl.length} chars`);
                
                // Validate data URL format
                if (!dataUrl.startsWith('data:application/pdf;base64,')) {
                    console.error('Invalid data URL format');
                    this.onPDFError('data-validation', transferMethod);
                    return;
                }
                
                if (window.pdfjsLib) {
                    try {
                        console.log('Attempting to load data URL with PDF.js...');
                        const loadingTask = window.pdfjsLib.getDocument(dataUrl);
                        const pdf = await loadingTask.promise;
                        
                        console.log(`PDF loaded successfully: ${pdf.numPages} pages`);
                        await this.renderPDF(pdf);
                        
                        // Add a small delay to account for browser's final paint operations
                        setTimeout(() => {
                            this.onPDFLoaded('pdfjs-dataurl', transferMethod);
                        }, 100);
                    } catch (error) {
                        console.warn('PDF.js data URL failed:', error);
                        console.log('Falling back to iframe method...');
                        
                        // Report the specific error but continue with fallback
                        this.sendMessageToUWP({
                            type: 'PDF_WARNING',
                            message: `PDF.js failed: ${error.message}, trying iframe fallback`,
                            method: 'pdfjs-dataurl',
                            transferMethod: transferMethod
                        });
                        
                        this.loadPDFInIframe(dataUrl, transferMethod);
                    }
                } else {
                    console.log('PDF.js not available, using iframe method');
                    this.loadPDFInIframe(dataUrl, transferMethod);
                }
            }

            useIframeMethod() {
                // For cloud-hosted MFE, iframe is often more reliable for file URLs
                // This can be made configurable based on your MFE environment
                // return true for cloud deployment, can be false for local testing
                return true; // Default to iframe method for maximum compatibility
            }

            loadPDFInIframe(pdfUrl, transferMethod = 'Unknown') {
                console.log(`Loading PDF in iframe: ${pdfUrl} (Method: ${transferMethod})`);
                
                const container = document.getElementById('pdfContainer');
                if (container) {
                    // Check for file URL and show immediate warning for browser environments
                    if (pdfUrl.startsWith('file:///') && !this.isInUWP) {
                        const errorMsg = 'File URL blocked by browser security. Use UWP WebView2 or convert to data URL.';
                        console.error('File URL Error:', errorMsg);
                        this.showFileUrlBlockedError(pdfUrl);
                        this.onPDFError('file-url-browser-blocked', transferMethod);
                        return;
                    }
                    
                    // Add enhanced error handling for iframe loading
                    const iframe = document.createElement('iframe');
                    iframe.src = pdfUrl;
                    iframe.width = '100%';
                    iframe.height = '70vh';
                    iframe.style.cssText = `
                        border: none;
                        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
                        border-radius: 8px;
                        background: white;
                    `;
                    iframe.className = 'pdf-frame';
                    iframe.title = 'PDF Preview';
                    
                    // Track if iframe has loaded successfully to avoid false error detection
                    let iframeLoadedSuccessfully = false;
                    
                    // Set up load/error handlers
                    iframe.onload = () => {
                        console.log('Iframe loaded successfully');
                        iframeLoadedSuccessfully = true;
                        
                        // For PDF iframes, implement smart timing that accounts for PDF rendering
                        this.waitForPDFToRender(iframe, transferMethod);
                    };
                    
                    iframe.onerror = (error) => {
                        console.error('Iframe failed to load:', error);
                        if (pdfUrl.startsWith('file:///')) {
                            this.showFileUrlBlockedError(pdfUrl);
                            this.onPDFError('file-url-not-allowed', transferMethod);
                        } else if (pdfUrl.startsWith('uwp-pdf://')) {
                            this.showStreamErrorMessage(pdfUrl);
                            this.onPDFError('stream-not-supported', transferMethod);
                        } else if (pdfUrl.startsWith('https://localassets.web/')) {
                            this.showVirtualHostErrorMessage(pdfUrl);
                            this.onPDFError('virtual-host-not-mapped', transferMethod);
                        } else {
                            this.onPDFError('iframe-load-error', transferMethod);
                        }
                    };
                    
                    container.innerHTML = '';
                    container.style.cssText = `
                        padding: 0;
                        background: #525659;
                        display: block;
                        width: 100%;
                        min-height: 70vh;
                    `;
                    container.appendChild(iframe);
                    
                    // Additional error detection for specific URL types (only if iframe doesn't load)
                    setTimeout(() => {
                        // Skip this check if iframe already loaded successfully
                        if (iframeLoadedSuccessfully) {
                            console.log('Iframe loaded successfully, skipping error detection check');
                            return;
                        }
                        
                        try {
                            // Try to access iframe content to detect security errors
                            // Note: For virtual host URLs, contentDocument will be null due to cross-origin,
                            // but this doesn't mean the mapping failed if iframe.onload was called
                            if (iframe.contentDocument === null) {
                                if (pdfUrl.startsWith('file:///')) {
                                    console.error('File URL access blocked by browser security');
                                    this.sendMessageToUWP({
                                        type: 'PDF_ERROR',
                                        error: 'Not allowed to load local resource: ' + pdfUrl,
                                        method: 'iframe',
                                        transferMethod: transferMethod
                                    });
                                } else if (pdfUrl.startsWith('uwp-pdf://')) {
                                    console.error('Custom stream handler not registered in UWP WebView2');
                                    this.showStreamErrorMessage(pdfUrl);
                                    this.sendMessageToUWP({
                                        type: 'PDF_ERROR',
                                        error: 'Custom scheme handler not registered: ' + pdfUrl,
                                        method: 'iframe',
                                        transferMethod: transferMethod,
                                        solution: 'Register uwp-pdf:// scheme handler in UWP application'
                                    });
                                } else if (pdfUrl.startsWith('https://localassets.web/')) {
                                    // For virtual host URLs, contentDocument being null is expected due to cross-origin
                                    // Only report error if onload event hasn't fired
                                    console.error('Virtual host mapping not configured in UWP WebView2 (no onload event fired)');
                                    this.showVirtualHostErrorMessage(pdfUrl);
                                    this.sendMessageToUWP({
                                        type: 'PDF_ERROR',
                                        error: 'Virtual host mapping not configured: ' + pdfUrl,
                                        method: 'iframe',
                                        transferMethod: transferMethod,
                                        solution: 'Configure SetVirtualHostNameToFolderMapping in UWP application'
                                    });
                                }
                            }
                        } catch (securityError) {
                            if (pdfUrl.startsWith('file:///')) {
                                console.error('Security error accessing file URL:', securityError);
                                this.sendMessageToUWP({
                                    type: 'PDF_ERROR',
                                    error: 'File URL access blocked: ' + securityError.message,
                                    method: 'iframe',
                                    transferMethod: transferMethod
                                });
                            } else if (pdfUrl.startsWith('uwp-pdf://')) {
                                console.error('Custom scheme error:', securityError);
                                this.showStreamErrorMessage(pdfUrl);
                                this.sendMessageToUWP({
                                    type: 'PDF_ERROR',
                                    error: 'Custom scheme failed: ' + securityError.message,
                                    method: 'iframe',
                                    transferMethod: transferMethod,
                                    solution: 'Register uwp-pdf:// scheme handler in UWP application'
                                });
                            } else if (pdfUrl.startsWith('https://localassets.web/')) {
                                console.error('Virtual host mapping error:', securityError);
                                this.showVirtualHostErrorMessage(pdfUrl);
                                this.sendMessageToUWP({
                                    type: 'PDF_ERROR',
                                    error: 'Virtual host mapping failed: ' + securityError.message,
                                    method: 'iframe',
                                    transferMethod: transferMethod,
                                    solution: 'Configure SetVirtualHostNameToFolderMapping in UWP application'
                                });
                            }
                        }
                    }, 1500); // 1.5 second timeout for better UX
                }
            }

            showStreamErrorMessage(streamUrl) {
                const container = document.getElementById('pdfContainer');
                if (container) {
                    container.innerHTML = `
                        <div class="placeholder" style="text-align: center; padding: 40px;">
                            <div class="placeholder-icon" style="font-size: 4em; margin-bottom: 20px;">⚠️</div>
                            <h3 style="color: #f57c00; margin-bottom: 15px;">Custom Stream Handler Not Registered</h3>
                            <p style="margin-bottom: 15px;"><strong>Stream URL:</strong> <code style="background: #f5f5f5; padding: 2px 4px; border-radius: 3px;">${streamUrl}</code></p>
                            <p style="margin-bottom: 20px; color: #d32f2f;"><strong>Error:</strong> "Failed to launch 'uwp-pdf://...' because the scheme does not have a registered handler"</p>
                            
                            <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; padding: 20px; margin: 20px 0; text-align: left;">
                                <h4 style="margin-top: 0; color: #856404;">🔧 UWP Fix Required:</h4>
                                <ol style="margin: 10px 0; padding-left: 20px;">
                                    <li><strong>Register Custom Scheme:</strong><br>
                                        <code style="background: #f8f9fa; padding: 4px 8px; border-radius: 3px; display: block; margin: 5px 0;">CoreWebView2.CustomSchemeRegistrations.Add(...)</code>
                                    </li>
                                    <li><strong>Add Resource Handler:</strong><br>
                                        <code style="background: #f8f9fa; padding: 4px 8px; border-radius: 3px; display: block; margin: 5px 0;">CoreWebView2.WebResourceRequested += OnCustomSchemeRequested</code>
                                    </li>
                                    <li><strong>Quick Alternative:</strong> Use file:// URLs instead</li>
                                </ol>
                            </div>
                            
                            <div style="background: #e8f5e8; border: 1px solid #4caf50; border-radius: 8px; padding: 15px; margin: 20px 0;">
                                <h4 style="margin-top: 0; color: #2e7d32;">📋 Quick Test:</h4>
                                <p style="margin: 5px 0;">1. Try "Test Data URL PDF" button - works immediately</p>
                                <p style="margin: 5px 0;">2. Try "Test File URL" - works in UWP with permissions</p>
                                <p style="margin: 5px 0;">3. See <code>CUSTOM-STREAM-QUICK-FIX.md</code> for implementation</p>
                            </div>
                        </div>
                    `;
                }
                showStatus('Custom stream handler not registered in UWP - see fix guide', 'error');
            }

            showFileUrlBlockedError(fileUrl) {
                const container = document.getElementById('pdfContainer');
                if (container) {
                    container.innerHTML = `
                        <div class="placeholder" style="text-align: center; padding: 40px;">
                            <div class="placeholder-icon" style="font-size: 4em; margin-bottom: 20px;">🚫</div>
                            <h3 style="color: #d32f2f; margin-bottom: 15px;">File URL Blocked</h3>
                            <p style="margin-bottom: 15px;"><strong>Error:</strong> "Not allowed to load local resource"</p>
                            <p style="margin-bottom: 20px; color: #666;">File URL: <code style="background: #f5f5f5; padding: 2px 4px; border-radius: 3px;">${fileUrl}</code></p>
                            
                            <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; padding: 20px; margin: 20px 0; text-align: left;">
                                <h4 style="margin-top: 0; color: #856404;">💡 Solutions:</h4>
                                <ol style="margin: 10px 0; padding-left: 20px;">
                                    <li><strong>UWP App Fix:</strong> Configure WebView2 with browser arguments:<br>
                                        <code style="background: #f8f9fa; padding: 4px 8px; border-radius: 3px; display: block; margin: 5px 0;">--allow-file-access-from-files --disable-web-security</code>
                                    </li>
                                    <li><strong>Alternative:</strong> Convert PDF to data URL in UWP:<br>
                                        <code style="background: #f8f9fa; padding: 4px 8px; border-radius: 3px; display: block; margin: 5px 0;">data:application/pdf;base64,{content}</code>
                                    </li>
                                </ol>
                            </div>
                            
                            <p style="font-size: 0.9em; color: #666;">See documentation for detailed implementation steps.</p>
                        </div>
                    `;
                }
                showStatus('File URL blocked by browser security - see solutions above', 'error');
            }

            showVirtualHostErrorMessage(virtualUrl) {
                const container = document.getElementById('pdfContainer');
                if (container) {
                    container.innerHTML = `
                        <div class="placeholder" style="text-align: center; padding: 40px;">
                            <div class="placeholder-icon" style="font-size: 4em; margin-bottom: 20px;">🌐</div>
                            <h3 style="color: #f57c00; margin-bottom: 15px;">Virtual Host Mapping Not Configured</h3>
                            <p style="margin-bottom: 15px;"><strong>Virtual URL:</strong> <code style="background: #f5f5f5; padding: 2px 4px; border-radius: 3px;">${virtualUrl}</code></p>
                            <p style="margin-bottom: 20px; color: #d32f2f;"><strong>Error:</strong> Virtual host "localassets.web" is not mapped to the local folder</p>
                            
                            <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; padding: 20px; margin: 20px 0; text-align: left;">
                                <h4 style="margin-top: 0; color: #856404;">🔧 UWP Fix Required:</h4>
                                <p style="margin-bottom: 10px;">Add this code to your UWP WebView2 initialization:</p>
                                <pre style="background: #f8f9fa; padding: 10px; border-radius: 4px; overflow-x: auto; font-size: 0.9em;"><code>string localFolderPath = ApplicationData.Current.LocalFolder.Path;
webView.CoreWebView2.SetVirtualHostNameToFolderMapping(
    "localassets.web",
    localFolderPath,
    CoreWebView2HostResourceAccessKind.Allow
);</code></pre>
                            </div>
                            
                            <div style="background: #e8f5e8; border: 1px solid #4caf50; border-radius: 8px; padding: 15px; margin: 20px 0;">
                                <h4 style="margin-top: 0; color: #2e7d32;">✅ Benefits of Virtual Host Mapping:</h4>
                                <ul style="text-align: left; margin: 5px 0; padding-left: 20px;">
                                    <li>More secure than file:// URLs</li>
                                    <li>No browser arguments required</li>
                                    <li>Works with modern WebView2 versions</li>
                                    <li>Direct file access without Base64 encoding</li>
                                </ul>
                            </div>
                            
                            <div style="background: #f3e5f5; border: 1px solid #9c27b0; border-radius: 8px; padding: 15px; margin: 20px 0;">
                                <h4 style="margin-top: 0; color: #7b1fa2;">🔄 Alternative Methods:</h4>
                                <p style="margin: 5px 0;">1. <strong>DataURL Method:</strong> Works immediately, higher memory usage</p>
                                <p style="margin: 5px 0;">2. <strong>CustomStream Method:</strong> Best performance, requires custom handler</p>
                                <p style="margin: 5px 0;">3. <strong>FileURL Method:</strong> Requires browser arguments or registry config</p>
                            </div>
                        </div>
                    `;
                }
                showStatus('Virtual host mapping not configured - see setup guide above', 'error');
            }

            async renderPDF(pdf) {
                // Enhanced PDF.js rendering with proper page layout
                const container = document.getElementById('pdfContainer');
                if (!container) return;

                // Create a scrollable container for PDF pages
                container.innerHTML = `
                    <div style="
                        width: 100%; 
                        height: 70vh; 
                        overflow-y: auto; 
                        overflow-x: auto;
                        background: #525659;
                        padding: 20px;
                        box-sizing: border-box;
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        gap: 10px;
                    " id="pdfPages">
                        <div style="color: white; margin-bottom: 10px;">Loading ${pdf.numPages} pages...</div>
                    </div>
                `;

                const pagesContainer = document.getElementById('pdfPages');
                
                // Calculate optimal scale based on container width
                const containerWidth = pagesContainer.clientWidth - 40; // Account for padding
                
                for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                    const page = await pdf.getPage(pageNum);
                    
                    // Get page dimensions at scale 1.0
                    const viewport = page.getViewport({ scale: 1.0 });
                    
                    // Calculate scale to fit width while maintaining aspect ratio
                    const scale = Math.min(containerWidth / viewport.width, 2.0); // Max scale of 2.0
                    const scaledViewport = page.getViewport({ scale: scale });
                    
                    // Create canvas for this page
                    const canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    
                    canvas.height = scaledViewport.height;
                    canvas.width = scaledViewport.width;
                    
                    // Style the canvas as a page
                    canvas.style.cssText = `
                        display: block;
                        margin: 0 auto 10px auto;
                        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
                        border: 1px solid #ccc;
                        background: white;
                        max-width: 100%;
                    `;
                    
                    // Add page to container
                    pagesContainer.appendChild(canvas);
                    
                    // Render the page
                    await page.render({
                        canvasContext: context,
                        viewport: scaledViewport
                    }).promise;
                    
                    // Update loading message
                    if (pageNum === 1) {
                        const loadingMsg = pagesContainer.querySelector('div');
                        if (loadingMsg) {
                            loadingMsg.textContent = `Rendering pages... (${pageNum}/${pdf.numPages})`;
                        }
                    }
                }
                
                // Remove loading message when done
                const loadingMsg = pagesContainer.querySelector('div');
                if (loadingMsg && loadingMsg.textContent.includes('Loading')) {
                    loadingMsg.remove();
                }
                
                console.log(`Successfully rendered ${pdf.numPages} pages`);
            }

            clearPDF() {
                const container = document.getElementById('pdfContainer');
                if (container) {
                    // Reset container styling
                    container.style.cssText = `
                        padding: 20px;
                        min-height: 400px;
                        background: #f8f9fa;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    `;
                    
                    container.innerHTML = `
                        <div class="placeholder">
                            <div class="placeholder-icon">📄</div>
                            <p>No PDF loaded - Waiting for PDF from UWP app...</p>
                        </div>
                    `;
                }
                
                // Reset chunking state if active
                if (this.chunkingState.isReceiving) {
                    console.log('Clearing PDF - resetting chunking state');
                    this.resetChunkingState();
                }
                
                filePathInput.value = '';
                showStatus('PDF preview cleared', 'success');
                
                this.sendMessageToUWP({
                    type: 'PDF_CLEARED',
                    message: 'PDF preview cleared'
                });
            }

            onPDFLoaded(method = 'unknown', transferMethod = 'Unknown') {
                console.log(`PDF loaded successfully using ${method} method (${transferMethod})`);
                showStatus('PDF loaded successfully from UWP storage!', 'success');
                
                // End timing when PDF is actually loaded
                this.endTiming(true, `Successfully loaded PDF using ${method} method (${transferMethod})`);
                
                this.sendMessageToUWP({
                    type: 'PDF_LOADED',
                    message: `PDF loaded in ${method} successfully`,
                    method: method,
                    transferMethod: transferMethod
                });
            }

            onPDFError(method = 'unknown', transferMethod = 'Unknown') {
                console.error(`Failed to load PDF using ${method} method (${transferMethod})`);
                showStatus('Failed to load PDF from UWP storage', 'error');
                
                // End timing when PDF loading fails
                this.endTiming(false, `Failed to load PDF using ${method} method (${transferMethod})`);
                
                this.sendMessageToUWP({
                    type: 'PDF_ERROR',
                    error: `Failed to load PDF in ${method}`,
                    method: method,
                    transferMethod: transferMethod
                });
            }

            showLoadingState() {
                const container = document.getElementById('pdfContainer');
                if (container) {
                    // Reset container to default styling for loading state
                    container.style.cssText = `
                        padding: 20px;
                        min-height: 400px;
                        background: #f8f9fa;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    `;
                    
                    container.innerHTML = `
                        <div class="placeholder">
                            <div class="loading-spinner"></div>
                            <p>Loading PDF from UWP...</p>
                        </div>
                    `;
                }
                showStatus('Loading PDF from UWP...', 'loading');
            }

            // === Chunked Streaming Methods ===
            
            startChunkedPDFLoad(message) {
                const transferMethod = message.transferMethod || 'ChunkedStream';
                console.log(`Starting chunked PDF load: ${message.fileName} (${message.totalChunks} chunks, ${message.totalSize} bytes, Method: ${transferMethod})`);
                
                // Start timing for chunked loading
                this.startTiming('Loading Chunked PDF', transferMethod, `Loading ${message.fileName} in ${message.totalChunks} chunks`);
                
                // Show loading state with progress
                this.showChunkedLoadingState(message.fileName, message.totalChunks);
                
                // Reset and initialize chunking state
                this.chunkingState = {
                    isReceiving: true,
                    chunks: new Array(message.totalChunks),
                    expectedChunks: message.totalChunks,
                    fileName: message.fileName,
                    totalSize: message.totalSize,
                    receivedChunks: 0,
                    transferMethod: transferMethod
                };
                
                // Update UI
                filePathInput.value = `Loading ${message.fileName} in chunks...`;
                
                // Notify UWP that we're ready to receive chunks
                this.sendMessageToUWP({
                    type: 'CHUNKED_START_ACK',
                    message: `Ready to receive ${message.totalChunks} chunks for ${message.fileName}`,
                    transferMethod: transferMethod
                });
            }
            
            receiveChunk(message) {
                if (!this.chunkingState.isReceiving) {
                    console.warn('Received chunk but not in receiving state');
                    this.sendMessageToUWP({
                        type: 'PDF_ERROR',
                        error: 'Received chunk but not in receiving state',
                        method: 'chunked',
                        transferMethod: this.chunkingState.transferMethod || 'ChunkedStream'
                    });
                    return;
                }
                
                const { chunkIndex, chunkData, isLastChunk } = message;
                
                console.log(`🔄 Processing chunk ${chunkIndex}, isLastChunk: ${isLastChunk}, expectedChunks: ${this.chunkingState.expectedChunks}, receivedSoFar: ${this.chunkingState.receivedChunks}`);
                
                // Validate chunk data
                if (chunkIndex === undefined || chunkIndex === null) {
                    console.error('Received chunk without valid index:', message);
                    this.sendMessageToUWP({
                        type: 'PDF_ERROR',
                        error: 'Chunk missing index',
                        method: 'chunked',
                        transferMethod: this.chunkingState.transferMethod || 'ChunkedStream'
                    });
                    return;
                }
                
                if (chunkData === undefined || chunkData === null || chunkData === '') {
                    console.error('Received chunk without valid data:', message);
                    this.sendMessageToUWP({
                        type: 'PDF_ERROR',
                        error: `Chunk ${chunkIndex} missing or empty data`,
                        method: 'chunked',
                        transferMethod: this.chunkingState.transferMethod || 'ChunkedStream'
                    });
                    return;
                }
                
                // Validate chunk index is within expected range
                if (chunkIndex < 0 || chunkIndex >= this.chunkingState.expectedChunks) {
                    console.error(`Chunk index ${chunkIndex} out of range (0-${this.chunkingState.expectedChunks - 1})`);
                    this.sendMessageToUWP({
                        type: 'PDF_ERROR',
                        error: `Chunk index ${chunkIndex} out of range`,
                        method: 'chunked',
                        transferMethod: this.chunkingState.transferMethod || 'ChunkedStream'
                    });
                    return;
                }
                
                console.log(`✅ Received chunk ${chunkIndex + 1}/${this.chunkingState.expectedChunks} (${chunkData.length} chars)${isLastChunk ? ' [FINAL]' : ''}`);
                
                // Store the chunk
                this.chunkingState.chunks[chunkIndex] = chunkData;
                this.chunkingState.receivedChunks++;
                
                console.log(`📊 State after storing chunk: receivedChunks=${this.chunkingState.receivedChunks}, expectedChunks=${this.chunkingState.expectedChunks}`);
                console.log(`📊 Chunks array state:`, this.chunkingState.chunks.map((chunk, i) => `[${i}]: ${chunk ? chunk.length + ' chars' : 'undefined'}`));
                
                // Update progress UI
                this.updateChunkedProgress();
                
                // Check if all chunks received - ONLY trigger assembly once
                const shouldAssemble = isLastChunk || this.chunkingState.receivedChunks === this.chunkingState.expectedChunks;
                console.log(`🔍 Assembly check: isLastChunk=${isLastChunk}, receivedChunks=${this.chunkingState.receivedChunks}, expectedChunks=${this.chunkingState.expectedChunks}, shouldAssemble=${shouldAssemble}`);
                
                if (shouldAssemble) {
                    console.log('🚀 All chunks received, assembling PDF...');
                    this.assembleAndLoadChunkedPDF();
                }
            }
            
            assembleAndLoadChunkedPDF() {
                // Guard against multiple calls to assembly
                if (!this.chunkingState.isReceiving) {
                    console.warn('🚫 Assembly called but not in receiving state - preventing duplicate assembly');
                    return;
                }
                
                try {
                    console.log('🔧 Assembling chunked PDF...');
                    console.log(`📊 Assembly stats: Expected chunks: ${this.chunkingState.expectedChunks}, Received: ${this.chunkingState.receivedChunks}`);
                    console.log(`📊 Chunks array length: ${this.chunkingState.chunks.length}`);
                    
                    // Validate all chunks are received - improved validation
                    const missingChunks = [];
                    for (let i = 0; i < this.chunkingState.expectedChunks; i++) {
                        const chunk = this.chunkingState.chunks[i];
                        if (chunk === undefined || chunk === null) {
                            missingChunks.push(i);
                        } else if (typeof chunk !== 'string') {
                            missingChunks.push(i);
                            console.error(`Chunk ${i} is not a string:`, typeof chunk, chunk);
                        }
                    }
                    
                    if (missingChunks.length > 0) {
                        console.error('❌ Missing chunks detected:', missingChunks);
                        console.error('Current chunks state:', this.chunkingState.chunks.map((chunk, i) => `[${i}]: ${chunk === undefined ? 'undefined' : chunk === null ? 'null' : typeof chunk + '(' + chunk.length + ' chars)'}`));
                        throw new Error(`Missing chunks: ${missingChunks.join(', ')}`);
                    }
                    
                    // Log each chunk for debugging - improved logging
                    console.log('📋 Chunk details:');
                    for (let i = 0; i < this.chunkingState.chunks.length; i++) {
                        const chunk = this.chunkingState.chunks[i];
                        console.log(`  Chunk ${i}: ${chunk ? chunk.length + ' chars' : 'null/undefined'}`);
                    }
                    
                    // Combine all chunks
                    const combinedBase64 = this.chunkingState.chunks.join('');
                    
                    console.log(`✅ Assembled PDF: ${combinedBase64.length} chars total`);
                    console.log(`🔍 First 50 chars: ${combinedBase64.substring(0, 50)}...`);
                    console.log(`🔍 Last 50 chars: ...${combinedBase64.substring(combinedBase64.length - 50)}`);
                    
                    // Validate the combined Base64 data
                    if (!combinedBase64 || combinedBase64.length === 0) {
                        throw new Error('No data in assembled chunks');
                    }
                    
                    // Check if it looks like valid Base64
                    if (!/^[A-Za-z0-9+/]*={0,2}$/.test(combinedBase64)) {
                        console.warn('⚠️ Assembled data may not be valid Base64');
                        console.log('Invalid characters found in Base64 data');
                    }
                    
                    const dataUrl = `data:application/pdf;base64,${combinedBase64}`;
                    
                    // Store fileName for use in loadDataUrlPDF
                    const fileName = this.chunkingState.fileName;
                    const expectedChunks = this.chunkingState.expectedChunks;
                    const transferMethod = this.chunkingState.transferMethod || 'ChunkedStream';
                    
                    console.log(`🎯 Loading assembled PDF: ${fileName} (${expectedChunks} chunks, Method: ${transferMethod})`);
                    
                    // Reset chunking state before loading to prevent re-entry
                    this.resetChunkingState();
                    
                    // Load the assembled PDF
                    this.loadDataUrlPDF(dataUrl, transferMethod);
                    
                    // Notify UWP of successful assembly
                    this.sendMessageToUWP({
                        type: 'PDF_LOADED',
                        message: `Chunked PDF assembled and loaded: ${fileName}`,
                        method: 'chunked',
                        chunks: expectedChunks,
                        fileName: fileName,
                        transferMethod: transferMethod
                    });

                    // End timing on successful completion
                    this.endTiming(true, `Successfully assembled and loaded ${fileName} from ${expectedChunks} chunks`);
                    
                } catch (error) {
                    console.error('💥 Error assembling chunked PDF:', error);
                    const transferMethod = this.chunkingState.transferMethod || 'ChunkedStream';
                    
                    // End timing on error
                    this.endTiming(false, `Failed to assemble chunked PDF: ${error.message}`);
                    
                    this.resetChunkingState();
                    this.sendMessageToUWP({
                        type: 'PDF_ERROR',
                        error: `Failed to assemble chunked PDF: ${error.message}`,
                        method: 'chunked',
                        transferMethod: transferMethod
                    });
                    showStatus(`Error assembling chunked PDF: ${error.message}`, 'error');
                }
            }
            
            showChunkedLoadingState(fileName, totalChunks) {
                const container = document.getElementById('pdfContainer');
                if (container) {
                    // Reset container to default styling
                    container.style.cssText = `
                        padding: 20px;
                        min-height: 400px;
                        background: #f8f9fa;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    `;
                    
                    container.innerHTML = `
                        <div class="placeholder">
                            <div class="loading-spinner"></div>
                            <h3>Loading PDF in Chunks</h3>
                            <p><strong>File:</strong> ${fileName}</p>
                            <p><strong>Total Chunks:</strong> ${totalChunks}</p>
                            <div id="chunkProgress" style="margin-top: 15px;">
                                <div style="background: #e0e0e0; border-radius: 10px; height: 20px; width: 300px; margin: 10px auto;">
                                    <div id="progressBar" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); height: 100%; border-radius: 10px; width: 0%; transition: width 0.3s ease;"></div>
                                </div>
                                <p id="progressText">Waiting for chunks... (0/${totalChunks})</p>
                            </div>
                        </div>
                    `;
                }
                showStatus(`Loading ${fileName} in ${totalChunks} chunks...`, 'loading');
            }
            
            updateChunkedProgress() {
                const progressBar = document.getElementById('progressBar');
                const progressText = document.getElementById('progressText');
                
                if (progressBar && progressText) {
                    const progress = (this.chunkingState.receivedChunks / this.chunkingState.expectedChunks) * 100;
                    progressBar.style.width = `${progress}%`;
                    progressText.textContent = `Received chunks: ${this.chunkingState.receivedChunks}/${this.chunkingState.expectedChunks} (${progress.toFixed(1)}%)`;
                    
                    // Update status
                    showStatus(`Loading chunks: ${this.chunkingState.receivedChunks}/${this.chunkingState.expectedChunks}`, 'loading');
                }
            }
            
            resetChunkingState() {
                this.chunkingState = {
                    isReceiving: false,
                    chunks: [],
                    expectedChunks: 0,
                    fileName: '',
                    totalSize: 0,
                    receivedChunks: 0,
                    transferMethod: 'Unknown'
                };
            }

            // === Timing Methods ===

            initializeTimingDisplay() {
                // Show timing section
                const timingSection = document.getElementById('timingSection');
                if (timingSection) {
                    timingSection.style.display = 'block';
                    this.updateTimingDisplay();
                }
            }

            startTiming(operation, method = 'Unknown', details = '') {
                this.timingState.startTime = performance.now();
                this.timingState.currentOperation = operation;
                this.timingState.currentMethod = method;
                this.timingState.operationDetails = details || `Loading PDF using ${method}`;
                
                console.log(`⏱️ Started timing: ${operation} (${method})`);
                this.updateTimingDisplay();
            }

            endTiming(success = true, additionalDetails = '') {
                if (!this.timingState.startTime) {
                    console.warn('endTiming called without startTiming');
                    return;
                }

                this.timingState.endTime = performance.now();
                const duration = this.timingState.endTime - this.timingState.startTime;
                
                // Add to load times array
                this.timingState.loadTimes.push({
                    duration: duration,
                    method: this.timingState.currentMethod,
                    success: success,
                    timestamp: new Date().toISOString()
                });

                // Keep only last 10 load times
                if (this.timingState.loadTimes.length > 10) {
                    this.timingState.loadTimes = this.timingState.loadTimes.slice(-10);
                }

                const status = success ? 'Completed' : 'Failed';
                this.timingState.currentOperation = status;
                this.timingState.operationDetails = additionalDetails || 
                    `${status} in ${this.formatDuration(duration)} using ${this.timingState.currentMethod}`;

                console.log(`⏱️ Ended timing: ${status} - ${this.formatDuration(duration)} (${this.timingState.currentMethod})`);
                this.updateTimingDisplay();

                // Reset timing after a delay
                setTimeout(() => {
                    this.timingState.currentOperation = 'Ready';
                    this.timingState.operationDetails = 'Waiting for PDF load request';
                    this.updateTimingDisplay();
                }, 3000);
            }

            updateTimingDisplay() {
                // Update current operation
                const operationStatus = document.getElementById('operationStatus');
                const operationDetails = document.getElementById('operationDetails');
                const currentOperation = document.getElementById('currentOperation');

                if (operationStatus) operationStatus.textContent = this.timingState.currentOperation;
                if (operationDetails) operationDetails.textContent = this.timingState.operationDetails;
                
                // Update operation status styling
                if (currentOperation) {
                    currentOperation.className = 'timing-item';
                    if (this.timingState.currentOperation === 'Loading' || this.timingState.currentOperation.includes('Loading')) {
                        currentOperation.classList.add('loading');
                    } else if (this.timingState.currentOperation === 'Completed') {
                        currentOperation.classList.add('success');
                    } else if (this.timingState.currentOperation === 'Failed') {
                        currentOperation.classList.add('error');
                    }
                }

                // Update last timing
                if (this.timingState.loadTimes.length > 0) {
                    const lastLoad = this.timingState.loadTimes[this.timingState.loadTimes.length - 1];
                    const lastDuration = document.getElementById('lastDuration');
                    const lastMethod = document.getElementById('lastMethod');
                    const lastTiming = document.getElementById('lastTiming');

                    if (lastDuration) lastDuration.textContent = this.formatDuration(lastLoad.duration);
                    if (lastMethod) lastMethod.textContent = `${lastLoad.method} - ${lastLoad.success ? 'Success' : 'Failed'}`;
                    
                    if (lastTiming) {
                        lastTiming.className = 'timing-item';
                        if (lastLoad.success) {
                            lastTiming.classList.add('success');
                        } else {
                            lastTiming.classList.add('error');
                        }
                    }
                }

                // Update average timing
                if (this.timingState.loadTimes.length > 0) {
                    const successfulLoads = this.timingState.loadTimes.filter(load => load.success);
                    if (successfulLoads.length > 0) {
                        const avgDuration = successfulLoads.reduce((sum, load) => sum + load.duration, 0) / successfulLoads.length;
                        const avgDurationEl = document.getElementById('avgDuration');
                        const totalLoadsEl = document.getElementById('totalLoads');
                        const averageTiming = document.getElementById('averageTiming');

                        if (avgDurationEl) avgDurationEl.textContent = this.formatDuration(avgDuration);
                        if (totalLoadsEl) totalLoadsEl.textContent = `${successfulLoads.length} successful loads`;
                        
                        if (averageTiming) {
                            averageTiming.className = 'timing-item success';
                        }
                    }
                }
            }

            formatDuration(milliseconds) {
                if (milliseconds < 1000) {
                    return `${Math.round(milliseconds)}ms`;
                } else if (milliseconds < 60000) {
                    return `${(milliseconds / 1000).toFixed(1)}s`;
                } else {
                    const minutes = Math.floor(milliseconds / 60000);
                    const seconds = ((milliseconds % 60000) / 1000).toFixed(1);
                    return `${minutes}m ${seconds}s`;
                }
            }

            sendMessageToUWP(message) {
                if (this.isInUWP) {
                    console.log('Sending message to UWP:', message);
                    window.chrome.webview.postMessage(JSON.stringify(message));
                }
            }

            notifyReady() {
                // Let UWP know the MFE is ready - matches sample-mfe-integration.js
                if (this.isInUWP) {
                    setTimeout(() => {
                        this.sendMessageToUWP({
                            type: 'MFE_READY',
                            message: 'MFE initialized and ready for PDF loading'
                        });
                        console.log('Notified UWP that MFE is ready');
                        
                        // Debug: Test custom stream handler
                        setTimeout(() => {
                            this.debugCustomStreamHandler();
                        }, 2000); // Wait 2 seconds after MFE ready
                    }, 1000);
                }
            }

            async checkVirtualHostReadiness() {
                console.log('🔍 Checking virtual host readiness...');
                
                // Check if virtual host readiness flags are set by UWP
                if (typeof window.virtualHostReady !== 'undefined') {
                    if (window.virtualHostReady === true) {
                        console.log('✅ Virtual host confirmed ready by UWP');
                        return { ready: true, reason: 'UWP confirmed ready' };
                    } else if (window.virtualHostUnsupported === true) {
                        console.log('❌ Virtual host unsupported by WebView2 version');
                        return { ready: false, reason: 'WebView2 version does not support virtual host mapping' };
                    } else if (window.virtualHostFailed === true) {
                        console.log('❌ Virtual host setup failed in UWP');
                        return { ready: false, reason: 'Virtual host mapping setup failed after multiple attempts' };
                    } else {
                        console.log('⚠️ Virtual host readiness flag set to false');
                        return { ready: false, reason: 'Virtual host mapping not ready yet' };
                    }
                }
                
                // If no flags are set, check if we're in development mode
                const isDevelopment = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                
                if (isDevelopment) {
                    console.log('🧪 Development mode detected - skipping virtual host test');
                    return { ready: false, reason: 'Development mode - virtual host not needed' };
                }
                
                // If no flags are set, perform a manual test
                console.log('🧪 No readiness flags found, performing manual virtual host test...');
                
                try {
                    // Test by fetching a known test file if it exists
                    const testUrl = 'https://localassets.web/virtualhost_verify.txt';
                    const response = await Promise.race([
                        fetch(testUrl),
                        new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 3000))
                    ]);
                    
                    if (response.ok) {
                        console.log('✅ Virtual host test successful');
                        return { ready: true, reason: 'Manual test successful' };
                    } else {
                        console.log(`⚠️ Virtual host test failed with status: ${response.status}`);
                        return { ready: false, reason: `Test fetch failed: ${response.status}` };
                    }
                } catch (error) {
                    console.log(`❌ Virtual host test error: ${error.message}`);
                    
                    // Common error patterns that indicate virtual host is not set up
                    if (error.message.includes('Failed to fetch') || 
                        error.message.includes('NetworkError') ||
                        error.message.includes('ERR_NAME_NOT_RESOLVED') ||
                        error.message.includes('Timeout')) {
                        return { ready: false, reason: 'Virtual host mapping not configured or accessible' };
                    }
                    
                    return { ready: false, reason: `Test error: ${error.message}` };
                }
            }

            waitForPDFToRender(iframe, transferMethod, attempt = 1, maxAttempts = 30) {
                // Enhanced detection for when PDF content is actually rendered and visible
                // This provides more accurate timing that reflects the actual user experience
                
                const checkInterval = 200; // Check every 200ms for more realistic timing
                const maxWaitTime = maxAttempts * checkInterval; // Max 6 seconds total
                
                console.log(`⏱️ Checking PDF render status (attempt ${attempt}/${maxAttempts})...`);
                
                try {
                    // Method 1: Progressive timing approach - require longer wait times for more confidence
                    const actualWaitTime = attempt * checkInterval;
                    const minWaitTime = 1500; // Minimum 1.5 seconds for realistic PDF loading
                    const confidenceWaitTime = 2500; // 2.5 seconds for high confidence
                    
                    // Method 2: Check iframe dimensions (basic requirement)
                    const hasValidDimensions = iframe.offsetHeight > 100 && iframe.offsetWidth > 100;
                    
                    // Method 3: Try to detect if the iframe appears to have loaded content
                    let hasContent = false;
                    try {
                        // For same-origin iframes, we can check if they have content
                        if (iframe.contentDocument && iframe.contentDocument.body) {
                            const bodyContent = iframe.contentDocument.body.innerText || iframe.contentDocument.body.textContent;
                            hasContent = bodyContent.length > 0;
                            console.log(`📄 Iframe content check: ${hasContent ? 'has content' : 'empty'}`);
                        } else {
                            // For cross-origin (like virtual host), we can't access content
                            // So we rely more heavily on timing
                            console.log(`🔒 Cross-origin iframe - using timing-based detection`);
                        }
                    } catch (crossOriginError) {
                        // Expected for cross-origin iframes (virtual host)
                        console.log(`🔒 Cross-origin access (expected for virtual host)`);
                    }
                    
                    // Decision logic: Be more conservative about when PDF is "ready"
                    const hasWaitedMinimum = actualWaitTime >= minWaitTime;
                    const hasWaitedConfidence = actualWaitTime >= confidenceWaitTime;
                    
                    // For cross-origin (virtual host), require longer wait time
                    const isVirtualHost = iframe.src && iframe.src.includes('localassets.web');
                    const requiredWaitTime = isVirtualHost ? confidenceWaitTime : minWaitTime;
                    
                    if (hasValidDimensions && actualWaitTime >= requiredWaitTime) {
                        console.log(`✅ PDF appears to be rendered (waited ${actualWaitTime}ms, method: ${isVirtualHost ? 'virtual-host' : 'standard'})`);
                        this.onPDFLoaded('iframe', transferMethod);
                        return;
                    }
                    
                    // Method 4: If we've waited the maximum time, assume it's ready
                    if (attempt >= maxAttempts) {
                        console.log(`⏰ Max wait time reached (${maxWaitTime}ms), assuming PDF is ready`);
                        this.onPDFLoaded('iframe', transferMethod);
                        return;
                    }
                    
                    // Continue checking with progress indicator
                    if (attempt % 5 === 0) { // Log every 1 second
                        console.log(`⏳ Still waiting for PDF to render... (${actualWaitTime}ms elapsed)`);
                    }
                    
                    setTimeout(() => {
                        this.waitForPDFToRender(iframe, transferMethod, attempt + 1, maxAttempts);
                    }, checkInterval);
                    
                } catch (error) {
                    console.warn(`Error checking PDF render status: ${error.message}`);
                    // Fall back to longer timing assumption
                    if (attempt >= 8) { // At least 1.6 seconds
                        console.log(`⏰ Falling back to timing assumption after error (waited ${attempt * checkInterval}ms)`);
                        this.onPDFLoaded('iframe', transferMethod);
                    } else {
                        setTimeout(() => {
                            this.waitForPDFToRender(iframe, transferMethod, attempt + 1, maxAttempts);
                        }, checkInterval);
                    }
                }
            }

            debugCustomStreamHandler() {
                // Debug method to test custom stream handler availability
                console.log('🔧 Debug: Testing Custom Stream Handler...');
                
                // Check if UWP has indicated custom stream availability
                if (typeof window.customStreamHandlerAvailable !== 'undefined') {
                    if (window.customStreamHandlerAvailable === false) {
                        console.log('❌ UWP has indicated custom stream handler is NOT available');
                        console.log('Reason: WebView2 runtime does not support custom scheme registration');
                        return;
                    } else if (window.customStreamHandlerAvailable === true) {
                        console.log('✅ UWP has indicated custom stream handler IS available');
                    }
                }
                
                // Try to fetch a test URL to see what happens
                const testUrl = 'uwp-pdf://test-debug';
                console.log(`🧪 Testing fetch to: ${testUrl}`);
                
                fetch(testUrl)
                    .then(response => {
                        console.log(`✅ Custom stream handler responded:`, response);
                        console.log(`Status: ${response.status} ${response.statusText}`);
                        return response.text();
                    })
                    .then(text => {
                        console.log(`Response body: ${text}`);
                    })
                    .catch(error => {
                        console.error(`❌ Custom stream handler error:`, error);
                        
                        // Check for specific error types
                        if (error.message.includes('scheme does not have a registered handler') || 
                            error.message.includes('URL scheme') || 
                            error.message.includes('not supported')) {
                            console.log(`💡 This error indicates the custom stream handler is not properly registered in UWP`);
                            console.log(`💡 Likely cause: WebView2 runtime version does not support custom scheme registration`);
                            console.log(`💡 Solution: Update WebView2 runtime or use alternative PDF loading methods`);
                        } else {
                            console.log(`💡 This indicates the custom stream handler is not properly registered in UWP`);
                        }
                    });
            }
        }

        // Check if running in UWP WebView2
        function checkUWPEnvironment() {
            isInUWP = window.chrome && window.chrome.webview;
            console.log('Running in UWP WebView2:', isInUWP);
            
            if (isInUWP) {
                console.log('UWP WebView2 detected - configuring for UWP mode');
                
                // Update UI for UWP mode
                selectFileBtn.style.display = 'none';
                filePathInput.placeholder = 'Waiting for PDF from UWP application...';
                filePathInput.readOnly = true;
                
                // Update instructions
                const placeholderDiv = document.querySelector('.placeholder p');
                if (placeholderDiv) {
                    placeholderDiv.textContent = 'Use the UWP application to select and load PDF files';
                }
                
                // Add UWP-specific styling
                document.body.classList.add('uwp-mode');
            } else {
                console.log('Running in regular browser mode');
                document.body.classList.add('browser-mode');
            }
        }

        // Legacy UWP functions for backward compatibility
        function setupUWPCommunication() {
            // UWP communication is now handled by UWPPDFIntegration class
            console.log('Legacy setupUWPCommunication called - delegating to UWPPDFIntegration');
        }

        function handleUWPMessage(data) {
            // Delegate to UWPPDFIntegration class
            if (window.uwpPDFIntegration) {
                window.uwpPDFIntegration.handleUWPMessage(data);
            }
        }

        async function loadPDFFromUWP(filePath) {
            // Delegate to UWPPDFIntegration class
            if (window.uwpPDFIntegration) {
                await window.uwpPDFIntegration.loadPDF(filePath);
            }
        }

        function clearPreview() {
            // Delegate to UWPPDFIntegration class
            if (window.uwpPDFIntegration) {
                window.uwpPDFIntegration.clearPDF();
            } else {
                // Fallback for non-UWP mode
                pdfContainer.innerHTML = `
                    <div class="placeholder">
                        <div class="placeholder-icon">📄</div>
                        <p>Enter a PDF file path above or click "Select File" to choose a PDF document</p>
                    </div>
                `;
                filePathInput.value = '';
                showStatus('Preview cleared', 'success');
            }
        }

        function notifyUWP(type, message, data = null) {
            // Delegate to UWPPDFIntegration class
            if (window.uwpPDFIntegration) {
                window.uwpPDFIntegration.sendMessageToUWP({
                    type: type,
                    message: message,
                    data: data,
                    timestamp: new Date().toISOString()
                });
            }
        }

        // Initialize the application
        function initializeApp() {
            console.log('Initializing PDF Preview App');
            
            // Initialize UWP integration first (matches sample-mfe-integration.js pattern)
            window.uwpPDFIntegration = new UWPPDFIntegration();
            
            // Check environment (legacy support)
            checkUWPEnvironment();
            setupIframeErrorHandling();
            
            // Set up event listeners only for non-UWP mode
            if (!isInUWP) {
                previewBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Preview button clicked');
                    previewPDF();
                });
                
                selectFileBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Select file button clicked');
                    fileSelector.click();
                });
                
                filePathInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        previewPDF();
                    }
                });

                filePathInput.addEventListener('input', (e) => {
                    // Clear current file when user types in the input
                    if (currentFile && e.target.value !== currentFile.name) {
                        console.log('Input changed, clearing current file');
                        currentFile = null;
                    }
                });

                fileSelector.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        console.log('File selected:', file.name);
                        currentFile = file;
                        filePathInput.value = file.name;
                        // Automatically preview the selected file
                        setTimeout(() => previewSelectedFile(), 100);
                    }
                });
            } else {
                // In UWP mode, disable manual interactions
                previewBtn.style.display = 'none';
                previewBtn.disabled = true;
            }
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', initializeApp);

        function setFilePath(element) {
            filePathInput.value = element.textContent;
            currentFile = null;
            filePathInput.focus();
        }

        function showStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
            statusDiv.style.display = 'block';
            
            // Notify UWP of status changes
            notifyUWP('status', message, { type: type });
            
            if (type === 'success') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 3000);
            }
        }

        function showLoading() {
            pdfContainer.innerHTML = `
                <div class="placeholder">
                    <div class="loading-spinner"></div>
                    <p>Loading PDF...</p>
                </div>
            `;
        }

        function showPlaceholder() {
            pdfContainer.innerHTML = `
                <div class="placeholder">
                    <div class="placeholder-icon">📄</div>
                    <p>Enter a PDF file path above or click "Select File" to choose a PDF document</p>
                </div>
            `;
        }

        async function previewSelectedFile() {
            console.log('previewSelectedFile called, currentFile:', currentFile);
            
            if (!currentFile) {
                showStatus('No file selected', 'error');
                return;
            }

            if (currentFile.type !== 'application/pdf') {
                showStatus('Selected file is not a PDF', 'error');
                return;
            }

            // Start timing for file selection preview
            if (window.uwpPDFIntegration) {
                window.uwpPDFIntegration.startTiming('Loading Selected File', 'File Selection', `Loading ${currentFile.name}`);
            }

            previewBtn.disabled = true;
            selectFileBtn.disabled = true;
            previewBtn.textContent = 'Loading...';
            showLoading();

            try {
                // Method 1: Try PDF.js first for better compatibility
                if (window.pdfjsLib) {
                    console.log('Using PDF.js to render selected file');
                    const arrayBuffer = await currentFile.arrayBuffer();
                    const loadingTask = window.pdfjsLib.getDocument(new Uint8Array(arrayBuffer));
                    const pdf = await loadingTask.promise;
                    
                    console.log(`PDF loaded with PDF.js: ${pdf.numPages} pages`);
                    await renderPDFWithPDFJS(pdf);
                    
                    showStatus('PDF loaded successfully with PDF.js!', 'success');
                    notifyUWP('pdfLoaded', 'PDF loaded successfully with PDF.js', { 
                        fileName: currentFile.name,
                        fileSize: currentFile.size,
                        pages: pdf.numPages,
                        method: 'pdfjs-fileSelection',
                        loadTime: new Date().toISOString()
                    });

                    // End timing on PDF.js success
                    if (window.uwpPDFIntegration) {
                        window.uwpPDFIntegration.endTiming(true, `Successfully loaded ${currentFile.name} with PDF.js (${pdf.numPages} pages)`);
                    }
                    return;
                }

                // Method 2: Fallback to iframe with object URL
                console.log('PDF.js not available, using iframe with object URL');
                const fileUrl = URL.createObjectURL(currentFile);
                console.log('Created file URL:', fileUrl);
                
                // Create iframe with better error handling
                const iframe = document.createElement('iframe');
                iframe.src = fileUrl;
                iframe.className = 'pdf-frame';
                iframe.title = 'PDF Preview';
                iframe.style.cssText = `
                    width: 100%;
                    height: 70vh;
                    border: none;
                    border-radius: 8px;
                    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
                    background: white;
                `;
                
                // Set up load and error handlers
                iframe.onload = () => {
                    console.log('PDF iframe loaded successfully');
                    showStatus('PDF loaded successfully!', 'success');
                    notifyUWP('pdfLoaded', 'PDF loaded successfully with iframe', { 
                        fileName: currentFile.name,
                        fileSize: currentFile.size,
                        method: 'iframe-fileSelection',
                        loadTime: new Date().toISOString()
                    });

                    // End timing on iframe success
                    if (window.uwpPDFIntegration) {
                        window.uwpPDFIntegration.endTiming(true, `Successfully loaded ${currentFile.name} with iframe`);
                    }
                };
                
                iframe.onerror = (error) => {
                    console.error('PDF iframe failed to load:', error);
                    showStatus('Failed to load PDF in iframe', 'error');
                    notifyUWP('error', 'Failed to load PDF iframe', { error: error.message });
                    showPlaceholder();

                    // End timing on iframe error
                    if (window.uwpPDFIntegration) {
                        window.uwpPDFIntegration.endTiming(false, `Failed to load ${currentFile.name} in iframe`);
                    }
                };
                
                // Set up container and add iframe
                pdfContainer.style.cssText = `
                    padding: 0;
                    background: #525659;
                    display: block;
                    width: 100%;
                    min-height: 70vh;
                `;
                pdfContainer.innerHTML = '';
                pdfContainer.appendChild(iframe);

                // Clean up object URL after iframe loads
                iframe.addEventListener('load', () => {
                    setTimeout(() => URL.revokeObjectURL(fileUrl), 1000);
                });

            } catch (error) {
                console.error('Error loading PDF:', error);
                showStatus('Failed to load PDF file', 'error');
                notifyUWP('error', 'Failed to load PDF file', { error: error.message });
                showPlaceholder();

                // End timing on catch error
                if (window.uwpPDFIntegration) {
                    window.uwpPDFIntegration.endTiming(false, `Failed to load ${currentFile?.name || 'file'}: ${error.message}`);
                }
            } finally {
                previewBtn.disabled = false;
                selectFileBtn.disabled = false;
                previewBtn.textContent = 'Preview PDF';
            }
        }

        // Helper function to render PDF with PDF.js
        async function renderPDFWithPDFJS(pdf) {
            const container = document.getElementById('pdfContainer');
            if (!container) return;

            // Reset container styling for PDF.js rendering
            container.style.cssText = `
                padding: 20px;
                background: #525659;
                display: block;
                width: 100%;
                min-height: 70vh;
                overflow-y: auto;
            `;

            // Create scrollable container for PDF pages
            container.innerHTML = `
                <div style="
                    width: 100%; 
                    overflow-y: auto; 
                    background: #525659;
                    padding: 20px;
                    box-sizing: border-box;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    gap: 10px;
                " id="pdfPages">
                    <div style="color: white; margin-bottom: 10px;">Loading ${pdf.numPages} pages...</div>
                </div>
            `;

            const pagesContainer = document.getElementById('pdfPages');
            const containerWidth = pagesContainer.clientWidth - 40; // Account for padding
            
            // Render each page
            for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                const page = await pdf.getPage(pageNum);
                const viewport = page.getViewport({ scale: 1.0 });
                const scale = Math.min(containerWidth / viewport.width, 2.0);
                const scaledViewport = page.getViewport({ scale: scale });
                
                // Create canvas for this page
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.height = scaledViewport.height;
                canvas.width = scaledViewport.width;
                
                canvas.style.cssText = `
                    display: block;
                    margin: 0 auto 10px auto;
                    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
                    border: 1px solid #ccc;
                    background: white;
                    max-width: 100%;
                `;
                
                pagesContainer.appendChild(canvas);
                
                // Render the page
                await page.render({
                    canvasContext: context,
                    viewport: scaledViewport
                }).promise;
                
                // Update loading message
                if (pageNum === 1) {
                    const loadingMsg = pagesContainer.querySelector('div');
                    if (loadingMsg) {
                        loadingMsg.textContent = `Rendering pages... (${pageNum}/${pdf.numPages})`;
                    }
                }
            }
            
            // Remove loading message when done
            const loadingMsg = pagesContainer.querySelector('div');
            if (loadingMsg && loadingMsg.textContent.includes('Loading')) {
                loadingMsg.remove();
            }
            
            console.log(`Successfully rendered ${pdf.numPages} pages with PDF.js`);
        }

        async function previewPDF() {
            console.log('previewPDF called');
            console.log('currentFile:', currentFile);
            console.log('filePath input value:', filePathInput.value);
            
            // If a file is selected, preview it directly
            if (currentFile) {
                console.log('Using selected file for preview');
                previewSelectedFile();
                return;
            }

            // Otherwise, try to preview from file path
            const filePath = filePathInput.value.trim();
            
            if (!filePath) {
                showStatus('Please enter a file path or select a file', 'error');
                return;
            }

            console.log('Using file path for preview:', filePath);

            previewBtn.disabled = true;
            selectFileBtn.disabled = true;
            previewBtn.textContent = 'Loading...';
            showLoading();

            try {
                // For file paths, try to load directly as file URL
                // Note: This only works in certain environments or with special browser settings
                const fileUrl = filePath.startsWith('file://') ? filePath : `file:///${filePath.replace(/\\/g, '/')}`;
                console.log('Constructed file URL:', fileUrl);
                
                // Create iframe to load the PDF
                pdfContainer.innerHTML = `
                    <iframe 
                        src="${fileUrl}" 
                        class="pdf-frame"
                        title="PDF Preview"
                        onload="console.log('PDF iframe loaded successfully'); showStatus('PDF loaded successfully!', 'success');"
                        onerror="console.error('PDF iframe failed to load'); showStatus('Failed to load PDF. File URLs may be blocked by browser security.', 'error');"
                    ></iframe>
                `;

                showStatus('PDF loading...', 'loading');
                notifyUWP('pdfLoading', 'PDF loading from file path', { 
                    filePath: filePath,
                    fileUrl: fileUrl,
                    method: 'filePath',
                    loadTime: new Date().toISOString()
                });

                // Set a timeout to detect if the iframe didn't load
                setTimeout(() => {
                    const iframe = pdfContainer.querySelector('iframe');
                    if (iframe) {
                        try {
                            // Check if iframe loaded content
                            if (iframe.contentDocument === null) {
                                showStatus('⚠️ File URL may be blocked by browser security. Try selecting a file instead.', 'error');
                                console.warn('File URL access blocked - iframe contentDocument is null');
                            }
                        } catch (securityError) {
                            console.warn('Security error accessing iframe:', securityError.message);
                            showStatus('✅ PDF loaded (security restrictions prevent verification)', 'success');
                        }
                    }
                }, 2000);

            } catch (error) {
                console.error('Error loading PDF from file path:', error);
                showStatus('Failed to load PDF from file path', 'error');
                notifyUWP('error', 'Failed to load PDF from file path', { error: error.message });
                showPlaceholder();
            } finally {
                previewBtn.disabled = false;
                selectFileBtn.disabled = false;
                previewBtn.textContent = 'Preview PDF';
            }
        }

        // Handle iframe load errors
        function setupIframeErrorHandling() {
            pdfContainer.addEventListener('load', (e) => {
                if (e.target.tagName === 'IFRAME') {
                    e.target.onerror = () => {
                        showStatus('Failed to load PDF. Please check the file path.', 'error');
                        notifyUWP('error', 'Failed to load PDF iframe');
                        showPlaceholder();
                    };
                }
            });
        }
    </script>
    
    <!-- UWP PDF Integration with Timing Measurement -->
    <script src="uwp-pdf-integration.js"></script>
</body>
</html>
